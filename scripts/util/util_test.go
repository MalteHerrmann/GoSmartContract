// util_tests.go contains the unit testing suite for the util module.
// The functions are tested using a simulated go-ethereum backend and
// generic accounts, generated by the crypto package.
package util

import (
	"context"
	"fmt"
	"math/big"
	"testing"

	maltcoin "github.com/MalteHerrmann/GoSmartContract/contracts/build"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/require"
)

// TestDeployContractAndCommit tests wether the generated contract bindings
// can be used to successfully deploy a smart contract on a simulated
// go-ethereum backend.
func TestDeployContractAndCommit(t *testing.T) {
	// Generate testing accounts
	privKeys, _, err := GeneratePrivKeysAndAddresses(1)
	require.NoError(t, err, "Error generating private key")

	testcases := []struct {
		name           string
		expErr         bool
		chainID        *big.Int
		maxGasPerBlock uint64
	}{
		{
			"valid client setup",
			false,
			TestChainID,
			MaxGasPerBlock,
		},
		{
			"too little maximum gas per block",
			true,
			TestChainID,
			uint64(100),
		},
		{
			"wrong chain ID for simulated client",
			true,
			big.NewInt(9000),
			MaxGasPerBlock,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			// Get simulated backend and transaction signer for testing
			client, auth, err := GetSimulatedClientAndTransactionSigner(privKeys[0], tc.maxGasPerBlock, tc.chainID)
			require.NoError(t, err, "Error getting client and transaction signer")

			// Deploy contract
			_, _, _, err = DeployContractAndCommit(auth, client)
			if tc.expErr {
				require.Error(t, err, "Deployed contract")
			} else {
				require.NoError(t, err, "Could not deploy contract")
			}
		})
	}
}

// TestFillTransactionSignerFields tests different configurations of client
// and call data to test the filling of the transaction signer fields.
// These fields include the nonce, gas price, gas limit and value.
//
// These tests need an instance of the local node running!
func TestFillTransactionSignerFields(t *testing.T) {
	privKey, err := crypto.GenerateKey()
	require.NoError(t, err, "Error generating private key")

	testcases := []struct {
		name     string
		expErr   bool
		callData []byte
	}{
		{
			"passes - empty data",
			false,
			[]byte{},
		},
		{
			"passes - deployment bin as data",
			false,
			common.FromHex(maltcoin.MaltcoinMetaData.Bin),
		},
		{
			"fails - invalid data",
			true,
			common.FromHex("abcdefg"),
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			client, auth, err := GetClientAndTransactionSigner(privKey)
			require.NoError(t, err, "Error getting client and transaction signer")

			_, err = FillTransactionSignerFields(auth, client, tc.callData)
			if tc.expErr {
				require.Error(t, err, "Error filling the transaction signer fields")
			} else {
				require.NoError(t, err, "Error filling the transaction signer fields")
			}
		})
	}
}

// TestGetClient tests if the connection to the local node is possible.
// For this purpose, the local node has to be running.
func TestGetClient(t *testing.T) {
	// Connect to local node
	client, err := GetClient()
	require.NoError(t, err, "Error getting client")

	// Check if chain ID is as expected
	chainID, err := client.ChainID(context.Background())
	require.NoError(t, err, "Error getting chain ID")
	require.Equal(t, big.NewInt(9000), chainID, "Wrong chain ID")
}

// TestGetReceiptSimulated tests if the receipts of transactions can correctly
// be retrieved using a simulated backend.
func TestGetReceiptSimulated(t *testing.T) {
	// Generate testing accounts
	privKeys, _, err := GeneratePrivKeysAndAddresses(1)
	require.NoError(t, err, "Error generating private key")

	// Get simulated backend and transaction signer for testing
	client, auth, err := GetSimulatedClientAndTransactionSigner(privKeys[0], MaxGasPerBlock, TestChainID)
	require.NoError(t, err, "Error getting simulated client and transaction signer")

	// Deploy contract
	_, tx, _, err := DeployContractAndCommit(auth, client)
	require.NoError(t, err, "Error deploying contract")

	fmt.Println("Deployed contract:", tx.Hash().Hex())

	// Set up testcases
	testcases := []struct {
		name   string
		expErr bool
		txHash string
		status uint64
	}{
		{
			"valid transaction hash",
			false,
			tx.Hash().Hex(),
			1,
		},
		{
			"invalid transaction hash",
			true,
			"0x0000000000000000000000000000000000000000000000000000000000000000",
			0,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			// Get receipt
			receipt, err := GetReceiptSimulated(client, tc.txHash)
			if tc.expErr {
				require.Error(t, err, "Getting receipt should raise an error")
			} else {
				require.NoError(t, err, "Error getting receipt")
				require.Equal(t, tc.status, receipt.Status, "Wrong receipt status")
			}
		})
	}
}

// TestGetSimulatedClientAndTransactionSigner tests if simulated backend
// as well as the transaction signer are setup as expected.
func TestGetSimulatedClientAndTransactionSigner(t *testing.T) {
	privKey, err := crypto.GenerateKey()
	require.NoError(t, err, "Error generating private key")

	// Get address for private key
	address := crypto.PubkeyToAddress(privKey.PublicKey)

	// Get simulated backend and transaction signer for testing
	client, auth, err := GetSimulatedClientAndTransactionSigner(privKey, MaxGasPerBlock, TestChainID)
	require.NoError(t, err, "Error setting up simulated client and transaction signer")

	// From address should correspond to private key
	require.Equal(t, address, auth.From, "Wrong address")

	// Nonce for address should be 0
	nonce, err := client.PendingNonceAt(context.Background(), auth.From)
	require.NoError(t, err, "Error getting nonce")
	require.Equal(t, uint64(0), nonce, "Wrong nonce")
}
