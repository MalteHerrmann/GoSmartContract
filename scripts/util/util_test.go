// util_tests.go contains the unit testing suite for the util module.
// The functions are tested using a simulated go-ethereum backend and
// generic accounts, generated by the crypto package.
package util

import (
	"context"
	"fmt"
	"math/big"
	"testing"

	maltcoin "github.com/MalteHerrmann/GoSmartContract/contracts/build"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/require"
)

var (
	// Has to be adjusted for the tests with the running local node
	testTxHashHex = "0xa9f7d8cb3a5a84c8740cd106c5334bdb13d09d4b81087a681fbc3ad2860dc557"
)

// TestDeployContractAndCommit tests wether the generated contract bindings
// can be used to successfully deploy a smart contract on a simulated
// go-ethereum backend.
func TestDeployContractAndCommit(t *testing.T) {
	// Generate testing accounts
	privKeys, _, err := GeneratePrivKeysAndAddresses(1)
	require.NoError(t, err, "Error generating private key")

	testcases := []struct {
		name           string
		expErr         bool
		chainID        *big.Int
		maxGasPerBlock uint64
	}{
		{
			"valid client setup",
			false,
			TestChainID,
			MaxGasPerBlock,
		},
		{
			"too little maximum gas per block",
			true,
			TestChainID,
			uint64(100),
		},
		{
			"wrong chain ID for simulated client",
			true,
			big.NewInt(9000),
			MaxGasPerBlock,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			// Get simulated backend and transaction signer for testing
			client, auth, err := GetSimulatedClientAndTransactionSigner(privKeys[0], tc.maxGasPerBlock, tc.chainID)
			require.NoError(t, err, "Error getting client and transaction signer")

			// Deploy contract
			_, _, _, err = DeployContractAndCommit(auth, client)
			if tc.expErr {
				require.Error(t, err, "Deployed contract")
			} else {
				require.NoError(t, err, "Could not deploy contract")
			}
		})
	}
}

// TestFillTransactionSignerFields tests different configurations of client
// and call data to test the filling of the transaction signer fields.
// These fields include the nonce, gas price, gas limit and value.
//
// These tests need an instance of the local node running!
func TestFillTransactionSignerFields(t *testing.T) {
	privKey, err := crypto.GenerateKey()
	require.NoError(t, err, "Error generating private key")

	testcases := []struct {
		name     string
		expErr   bool
		callData []byte
	}{
		{
			"passes - empty data",
			false,
			[]byte{},
		},
		{
			"passes - deployment bin as data",
			false,
			common.FromHex(maltcoin.MaltcoinMetaData.Bin),
		},
		{
			"fails - invalid data",
			true,
			common.FromHex("abcdefg"),
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			client, auth, err := GetClientAndTransactionSigner(privKey)
			require.NoError(t, err, "Error getting client and transaction signer")

			// Define call msg
			msg := ethereum.CallMsg{
				From: auth.From,
				Data: tc.callData,
			}

			_, err = FillTransactionSignerFields(auth, client, msg)
			if tc.expErr {
				require.Error(t, err, "Error filling the transaction signer fields")
			} else {
				require.NoError(t, err, "Error filling the transaction signer fields")
			}
		})
	}
}

// TestGetCallData tests if call data for an ethereum callMsg can
// be correctly generated.
func TestGetCallData(t *testing.T) {
	testcases := []struct {
		name       string
		expErr     bool
		methodName string
		args       []interface{}
	}{
		{
			"passes - transfer call",
			false,
			"transfer",
			[]interface{}{
				common.HexToAddress("0x1234567890123456789012345678901234567890"),
				big.NewInt(1),
			},
		},
		{
			"fails - invalid method name",
			true,
			"InvalidMethodName",
			[]interface{}{},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			callData, err := GetCallData(tc.methodName, tc.args...)
			if tc.expErr {
				require.Error(t, err, "Error getting call data")
			} else {
				require.NoError(t, err, "Error getting call data")
				require.NotNil(t, callData, "Call data is nil")
			}
		})
	}
}

// TestGetClient tests if the connection to the local node is possible.
// For this purpose, the local node has to be running.
func TestGetClient(t *testing.T) {
	// Connect to local node
	client, err := GetClient()
	require.NoError(t, err, "Error getting client")

	// Check if chain ID is as expected
	chainID, err := client.ChainID(context.Background())
	require.NoError(t, err, "Error getting chain ID")
	require.Equal(t, big.NewInt(9000), chainID, "Wrong chain ID")
}

// TestGetReceipt tests if the receipts of transactions can correctly
// be retrieved using a connection to a local node.
func TestGetReceipt(t *testing.T) {
	// Get client
	client, err := GetClient()
	require.NoError(t, err, "Error getting client and transaction signer")

	// Get receipt for valid transaction
	receipt, err := GetReceipt(client, testTxHashHex)
	require.NoError(t, err, "Error getting receipt")
	require.Equal(t, receipt.Status, uint64(1), "Wrong receipt status")

	// Get receipt for invalid transaction
	_, err = GetReceipt(client, "0xabcdefg")
	require.Error(t, err, "Invalid transaction hash should not return receipt")
}

// TestGetReceiptSimulated tests if the receipts of transactions can correctly
// be retrieved using a simulated backend.
func TestGetReceiptSimulated(t *testing.T) {
	// Generate testing accounts
	privKeys, _, err := GeneratePrivKeysAndAddresses(1)
	require.NoError(t, err, "Error generating private key")

	// Get simulated backend and transaction signer for testing
	client, auth, err := GetSimulatedClientAndTransactionSigner(privKeys[0], MaxGasPerBlock, TestChainID)
	require.NoError(t, err, "Error getting simulated client and transaction signer")

	// Deploy contract
	_, tx, _, err := DeployContractAndCommit(auth, client)
	require.NoError(t, err, "Error deploying contract")

	fmt.Println("Deployed contract:", tx.Hash().Hex())

	// Set up testcases
	testcases := []struct {
		name   string
		expErr bool
		txHash string
		status uint64
	}{
		{
			"valid transaction hash",
			false,
			tx.Hash().Hex(),
			1,
		},
		{
			"invalid transaction hash",
			true,
			"0x0000000000000000000000000000000000000000000000000000000000000000",
			0,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			// Get receipt
			receipt, err := GetReceiptSimulated(client, tc.txHash)
			if tc.expErr {
				require.Error(t, err, "Getting receipt should raise an error")
			} else {
				require.NoError(t, err, "Error getting receipt")
				require.Equal(t, tc.status, receipt.Status, "Wrong receipt status")
			}
		})
	}
}

// TestGetSimulatedClientAndTransactionSigner tests if simulated backend
// as well as the transaction signer are setup as expected.
func TestGetSimulatedClientAndTransactionSigner(t *testing.T) {
	privKey, err := crypto.GenerateKey()
	require.NoError(t, err, "Error generating private key")

	// Get address for private key
	address := crypto.PubkeyToAddress(privKey.PublicKey)

	// Get simulated backend and transaction signer for testing
	client, auth, err := GetSimulatedClientAndTransactionSigner(privKey, MaxGasPerBlock, TestChainID)
	require.NoError(t, err, "Error setting up simulated client and transaction signer")

	// From address should correspond to private key
	require.Equal(t, address, auth.From, "Wrong address")

	// Nonce for address should be 0
	nonce, err := client.PendingNonceAt(context.Background(), auth.From)
	require.NoError(t, err, "Error getting nonce")
	require.Equal(t, uint64(0), nonce, "Wrong nonce")
}
