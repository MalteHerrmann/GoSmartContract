// maltcoin_bdd_test.go contains the testing suite for the Maltcoin smart contract.
//
// The token properties and functions are tested using a simulated go-ethereum
// backend and private keys generated by the crypto package.
package maltcoin_tests

import (
	"crypto/ecdsa"
	"log"
	"math/big"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	maltcoin "github.com/MalteHerrmann/GoSmartContract/contracts/build"
	"github.com/MalteHerrmann/GoSmartContract/scripts/util"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/accounts/abi/bind/backends"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/suite"
)

// MaltcoinTestSuite defines the test suite for the Maltcoin smart contract.
// It contains slices of private keys and addresses, which are used to test the
// contract methods.
type MaltcoinTestSuite struct {
	suite.Suite

	addresses       []common.Address
	auth            *bind.TransactOpts
	client          *backends.SimulatedBackend
	contract        *maltcoin.Maltcoin
	deployerBalance *big.Int
	privKeys        []*ecdsa.PrivateKey
}

// Initialize the test suite
var s *MaltcoinTestSuite

// SetupTest defines the procedure for setting up BDD tests of the contract
// methods. For this, an instance of the Maltcoin smart contract is deployed
// to a simulated backend.
func (suite *MaltcoinTestSuite) SetupTest() {
	// Generate testing accounts
	privKeys, addresses, err := util.GeneratePrivKeysAndAddresses(2)
	if err != nil {
		log.Fatalf("Error generating private key: %v\n", err)
	}

	// Get simulated backend and transaction signer for testing
	client, auth, _ := util.GetSimulatedClientAndTransactionSigner(privKeys[0], util.MaxGasPerBlock, util.TestChainID)
	// require.NoError(s.T(), err, "Error getting client and transaction signer")

	// Deploy contract
	_, _, contract, _ := util.DeployContractAndCommit(auth, client)
	// require.NoError(s.T(), err, "Could not deploy contract")

	// Assign to testing suite
	suite.addresses = addresses
	suite.auth = auth
	suite.client = client
	suite.contract = contract
	suite.deployerBalance = new(big.Int).Mul(big.NewInt(10000), util.Ten18) // 10000 MALT
	suite.privKeys = privKeys
}

// TestMaltcoin initializes the test suite and runs the tests.
func TestMaltcoin(t *testing.T) {
	s = new(MaltcoinTestSuite)
	suite.Run(t, s)

	RegisterFailHandler(Fail)
	RunSpecs(t, "Maltcoin Suite")
}

var _ = Describe("Token approve", func() {
	BeforeEach(func() {
		s.SetupTest()
	})

	Context("When approving a transaction amount", Ordered, func() {
		It("should have added the amount to the allowance of the recipient address", func() {
			// Define approved amount
			amount := util.Ten18

			// Approve tokens from account1 to account2
			_, err := s.contract.Approve(s.auth, s.addresses[1], amount)
			Expect(err).To(BeNil())

			// Commit transaction
			s.client.Commit()

			allowance, err := s.contract.Allowance(nil, s.addresses[0], s.addresses[1])
			Expect(allowance.Cmp(amount), err).To(Equal(0))
		})
	})
})

var _ = Describe("Token balance", Ordered, func() {
	BeforeEach(func() {
		s.SetupTest()
	})

	Context("Deployer balance after deployment", func() {
		It("should be 10000 MALT", func() {
			balance, err := s.contract.BalanceOf(nil, s.addresses[0])
			Expect(err).To(BeNil())
			Expect(balance.Cmp(s.deployerBalance)).To(Equal(0))
		})
	})
	Context("Other accounts' balances after deployment", func() {
		It("should be 0 MALT", func() {
			balance, err := s.contract.BalanceOf(nil, s.addresses[1])
			Expect(err).To(BeNil())
			Expect(balance.Cmp(new(big.Int))).To(Equal(0))
		})
	})
})

var _ = Describe("Token transfer", func() {
	BeforeEach(func() {
		s.SetupTest()
	})

	Context("When sender has sufficient tokens", Ordered, func() {
		// Define transferred amount
		amount := util.Ten18

		BeforeEach(func() {
			// Transfer tokens from account1 to account2
			_, err := s.contract.Transfer(s.auth, s.addresses[1], amount)
			Expect(err).To(BeNil())

			// Commit transaction
			s.client.Commit()
		})

		It("should have deducted the transferred amount from the sender balance", func() {
			senderBalance, err := s.contract.BalanceOf(nil, s.addresses[0])
			Expect(err).To(BeNil())
			Expect(senderBalance.Cmp(new(big.Int).Sub(s.deployerBalance, amount))).To(Equal(0))
		})

		It("should have increased the recipient balance by the transferred amount", func() {
			recipientBalance, err := s.contract.BalanceOf(nil, s.addresses[1])
			Expect(err).To(BeNil())
			Expect(recipientBalance.Cmp(amount)).To(Equal(0))
		})
	})

	Context("When sender does not have sufficient tokens", Ordered, func() {
		// Define transferred amount
		amount := new(big.Int).Mul(big.NewInt(100000), util.Ten18)

		BeforeEach(func() {
			// Transfer tokens from account1 to account2
			_, err := s.contract.Transfer(s.auth, s.addresses[1], amount)
			Expect(err).Error()

			// Commit transaction
			s.client.Commit()
		})

		It("should not have deducted the transferred amount from the sender balance", func() {
			senderBalance, err := s.contract.BalanceOf(nil, s.addresses[0])
			Expect(senderBalance.Cmp(s.deployerBalance), err).To(Equal(0))
		})

		It("should not have increased the recipient balance", func() {
			recipientBalance, err := s.contract.BalanceOf(nil, s.addresses[1])
			Expect(recipientBalance.Cmp(big.NewInt(0)), err).To(Equal(0))
		})
	})
})
