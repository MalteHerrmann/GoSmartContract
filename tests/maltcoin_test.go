// maltcoin_test.go contains the testing suite for the Maltcoin smart contract.
//
// The token properties and functions are tested using a simulated go-ethereum
// backend and private keys generated by the crypto package.
package maltcoin_tests

import (
	"log"
	"math/big"
	"testing"

	"github.com/MalteHerrmann/GoSmartContract/scripts/util"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/require"
)

// TestTokenBalance tests querying the token balance for accounts
// of the Maltcoin smart contract.
//
// It creates two private keys with the corresponding addresses, which
// are used to transfer tokens.
// An instance of the Maltcoin smart contract is deployed on a simulated
// backend, so one of the accounts should have the initial deployer balance,
// which is 10000 MALT and the other should have 0.
func TestTokenBalance(t *testing.T) {
	// Generate testing accounts
	privKeys, addresses, err := util.GeneratePrivKeysAndAddresses(2)
	if err != nil {
		log.Fatalf("Error generating private key: %v\n", err)
	}

	// Get simulated backend and transaction signer for testing
	client, auth, err := util.GetSimulatedClientAndTransactionSigner(privKeys[0], util.MaxGasPerBlock, util.TestChainID)
	require.NoError(t, err, "Error getting client and transaction signer")

	// Deploy contract
	_, _, contract, err := util.DeployContractAndCommit(auth, client)
	require.NoError(t, err, "Could not deploy contract")

	// Define 10000 * 10^18 as a big integer.
	initialDeployerBalance := new(big.Int).Mul(big.NewInt(10000), util.Ten18)

	// Check maltcoin token balance of account1
	// This account deployed the contract, so it should have the initial deployer token balance.
	balance, err := contract.BalanceOf(nil, addresses[0])
	require.NoError(t, err, "Could not retrieve balance of deployer account")
	require.Equal(t, initialDeployerBalance, balance, "Wrong balance of deployer account")

	// Get balance of account2
	balance, err = contract.BalanceOf(nil, addresses[1])
	require.NoError(t, err, "Could not retrieve balance of account2")
	require.Equal(t, int64(0), balance.Int64(), "Wrong balance of account2")
}

// TestTokenTransfer tests the token transfer of the Maltcoin smart contract.
//
// It creates two private keys with the corresponding addresses, which
// are used to transfer tokens.
// An instance of the Maltcoin smart contract is deployed on a simulated
// backend, a transfer is executed and the account balances are checked.
func TestTokenTransfer(t *testing.T) {
	// Generate testing accounts
	privKeys, addresses, err := util.GeneratePrivKeysAndAddresses(2)
	if err != nil {
		log.Fatalf("Error generating private key: %v\n", err)
	}

	// Get simulated backend and transaction signer for testing
	client, auth, err := util.GetSimulatedClientAndTransactionSigner(privKeys[0], util.MaxGasPerBlock, util.TestChainID)
	require.NoError(t, err, "Error getting client and transaction signer")

	// Deploy contract
	_, _, contract, err := util.DeployContractAndCommit(auth, client)
	require.NoError(t, err, "Could not deploy contract")

	// Get maltcoin token balance of account1
	//
	// Since account1 deployed the contract, it is assigned the deployer token balance.
	// This is 10000 * 10^18 in this case.
	initialDeployerBalance := new(big.Int).Mul(big.NewInt(10000), util.Ten18)

	// Transfer tokens from account1 to account2
	amount := util.Ten18
	_, err = contract.Transfer(auth, addresses[1], amount)
	require.NoError(t, err, "Could not transfer tokens")
	client.Commit()

	// Check if transfer was successful
	balance, err := contract.BalanceOf(nil, addresses[0])
	require.NoError(t, err, "Could not retrieve balance of sender account after transfer")
	require.Equal(t, new(big.Int).Sub(initialDeployerBalance, amount), balance, "Wrong balance of sender account after transfer")

	balance, err = contract.BalanceOf(nil, addresses[1])
	require.NoError(t, err, "Could not retrieve balance of recipient account after transfer")
	require.Equal(t, amount, balance, "Wrong balance of recipient account after transfer")
}

// TestTokenSettings tests if the smart contract returns the expected
// token properties (name, symbol, decimals, total supply)..
// It checks if any errors are produced
func TestTokenSettings(t *testing.T) {
	// Test parameters
	blockGasLimit := uint64(4712388)

	// Define chain ID for simulated backend.
	// As described in the go-ethereum documentation, the chain ID for
	// the simulated backend must be 1337.
	chainID := big.NewInt(1337)

	// Generate private key
	privKey, err := crypto.GenerateKey()
	require.NoError(t, err, "Error generating private key")

	// Get simulated backend and transaction signer for testing
	client, auth, err := util.GetSimulatedClientAndTransactionSigner(privKey, blockGasLimit, chainID)
	require.NoError(t, err, "Error getting client and transaction signer")

	// Deploy contract
	_, _, contract, err := util.DeployContractAndCommit(auth, client)
	require.NoError(t, err, "Could not deploy contract")

	// Get name of token
	name, err := contract.Name(nil)
	require.NoError(t, err, "Could not retrieve token name")
	require.Equal(t, "Maltcoin", name, "Token name should be Maltcoin")

	// Get token symbol
	symbol, err := contract.Symbol(nil)
	require.NoError(t, err, "Could not retrieve token symbol")
	require.Equal(t, "MALT", symbol, "Token symbol should be MALT")

	// Get token decimals
	decimals, err := contract.Decimals(nil)
	require.NoError(t, err, "Could not retrieve token decimals")
	require.Equal(t, uint8(18), decimals, "Token decimals should be 18")

	// Get total supply
	totalSupply, err := contract.TotalSupply(nil)
	require.NoError(t, err, "Could not retrieve total supply")
	require.Equal(t, "10000000000000000000000", totalSupply.String(), "Wrong total supply")
}
